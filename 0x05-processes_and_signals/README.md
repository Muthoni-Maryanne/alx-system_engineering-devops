# 0x05. Processes and signals
This is a continuation of shell and bash scripting that looks at processes, types, states, priority of a process-nice value, proc file, pid, parent process, child process, ps, top, signals, killing a process and process environment.

## Resources
1. [Linux PID](https://www.linfo.org/pid.html)
2. [Linux Processes](https://www.thegeekstuff.com/2012/03/linux-processes-environment/)
3. [Linux signal](https://www.educative.io/answers/what-are-linux-signals)
4. [Process Management in Linux](https://www.digitalocean.com/community/tutorials/process-management-in-linux)
5. [Linux signals](https://www.computerhope.com/unix/signals.htm)

## Learning objectives

- What is a PID
- What is a process
- How to find a process’ PID
- How to kill a process
- What is a signal
- What are the 2 signals that cannot be ignored

## Summary
**PID (process identification number)**

process: instance of a program, how Linux handles multi tasking.Each process given unique PID.

PID: An identification number that is automatically assigned to each process when it is created on a Unix-like operating system.

**Process environment**

A process also has its environment. There are two ways in which we can access a process environment:
- Through the global variable ‘extern char **extern‘
- Through the third argument to the main() function ‘char *envp[]’

Historically a third argument (the environment array) to the main() function was present. But ISO C specifies that the main() function to be written with only two arguments. Hence we do not use this third argument when we specify main function. But, we could access this envp[] inside the program. Anyways, The following code snippet specifies how to access the environment from within a process:
```
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

extern char **environ;

int main(int argc, char *argv[])
{
  int count = 0;

  printf("\n");
  while(environ[count] != NULL)
  {
    printf("[%s] :: ", environ[count]);
    count++;
  }

  char *val = getenv("USER");
  printf("\n\nCurrent value of environment variable USER is [%s]\n",val);

  if(setenv("USER","Arora",1))
  {
    printf("\n setenv() failed\n");
    return 1;
  }

  printf("\n Successfully Added a new value to existing environment variable USER\n");

  val = getenv("USER");
  printf("\nNew value of environment variable USER is [%s]\n",val);

  while(1)
  {
    sleep(2);
  }
  return 0;
}
```
In above code, global variable ‘environ’ to access all the environment variables. Also we have used two functions :

- getenv – Get value of a particular environment variable
- setenv – Set a new value to an environment variable

**Signals**

An event generated by the UNIX and Linux systems in response to some condition. Upon receipt of a signal, a process may take action. Two types of signals:

- Maskable: signals which can be changed or ignored by the user (e.g., Ctrl+C).
- Non-Maskable: signals which cannot be changed or ignored by the user. These typically occur when the user is signaled for non-recoverable hardware errors (e.g KILL, STOP).

**Process management**

In Linux processes can be of two types:
- Foreground Processes
- Background Processes

Process States in Linux: Running- R, Sleeping- S, Uninterrupted sleep- D, Stopped- T, Zombie- Z, High priority- < and Low priority- N.

Different Commands for Process Management in Linux:

There are two commands available in Linux to track running processes. These two commands are Top and Ps.

To stop a process: ```$ kill [pid]``` or ```$ kill [signal] [pid]```.

To change priority of new process:```$ nice -n [value] [process name]``` or already running process: ```renice [value] -p 'PID'```.

## Tasks
