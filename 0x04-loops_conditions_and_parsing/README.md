# 0x04. Loops, conditions and parsing

Continuation of the shell, I began working with loops and conditionals in Bash.

## Resources
1. [Loops sample](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_01.html)
2. [Variable assignment and arithmetic](https://tldp.org/LDP/abs/html/ops.html)
3. [Comparison operators](https://tldp.org/LDP/abs/html/comparison-ops.html)
4. [File test operators](https://tldp.org/LDP/abs/html/fto.html)

## Summary
**For loop**

Syntax: ```for NAME [in LIST ]; do COMMANDS; done```

If [in LIST] is not present, it is replaced with in $@ and for executes the COMMANDS once for each positional parameter that is set.
NAME can be any variable name, although i is used very often. 
LIST can be any list of words, strings or numbers, which can be literal or generated by any command.
The COMMANDS to execute can also be any operating system commands, script, program or shell statement.
The return status is the exit status of the last command that executes. 
If no commands are executed because LIST does not expand to any items, the return status is zero.

Example:
```
#!/usr/bin/env bash
# specific conversion script for my html files to php

# Assuming beginfile and endfile contain PHP code
beginfile="path/to/beginfile.php"
endfile="path/to/endfile.php"

for file in *.html; do
    new_name=$(echo "$file" | sed 's/html$/php/')
    
    # Copy contents of beginfile to new PHP file
    cat "$beginfile" > "$new_name"
    
    # Append manipulated HTML content to new PHP file
    sed -e '1,25d' "$file" | tac | sed -e '1,21d' | tac >> "$new_name"
    
    # Append contents of endfile to new PHP file
    cat "$endfile" >> "$new_name"
done
```
**Operators**

1. assignment: =
2. arithmetic: +, -, *, /, **, %, +=, -=, *=, /=, %=
3. Bitwise: <<, <<=, >>, >>=, &, &=, |, |=, ^, ^=, ~
4. Logical/boolean: &&, ||, !
5. Comma operator.

**Other comparison operators**

1. Integer comparison: -eq, -ne, -gt, -ge, -lt, <, <=, >, >=

Example: ```if [ "$a" -le "$b" ]``` or ```(("$a" < "$b"))```

2. String comparison: =, ==, <, >, -z, -n

Example: ```if [ "$a" = "$b" ]``` or ```if [[ "$a" < "$b" ]]``` 0r ```if [ "$a" \< "$b" ]```

Example of arithmetic and string comparisons:
```
#!/bin/bash

a=4
b=5

#  Here "a" and "b" can be treated either as integers or strings.
#  Bash permits integer operations and comparisons on variables
#+ whose value consists of all-integer characters.

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# In this particular instance, both "-ne" and "!=" work.

echo

exit 0
```

3. Compound comparison: -a, -o, similar to && and ||

```[ condition1 -a condition2 ]``` or ```[[ condition1 && condition2 ]]```

```[ condition1 -o condition2 ]``` or ```[[ condition1 || condition2 ]]```

**File test operators**

-e/-a, -f, -s, -d, -b, -c, -p, -h, -L, -S, -t, -r, -w, -x, -g, -u, -K, -O, -G, -N, f1 -nt f2, f1 -ot f2, f1 -ef f2, !
