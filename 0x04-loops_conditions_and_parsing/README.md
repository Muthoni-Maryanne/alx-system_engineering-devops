# 0x04. Loops, conditions and parsing

Continuation of the shell, I began working with loops and conditionals in Bash.

## Resources
1. [Loops sample](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_01.html)
2. [Variable assignment and arithmetic](https://tldp.org/LDP/abs/html/ops.html)
3. [Comparison operators](https://tldp.org/LDP/abs/html/comparison-ops.html)
4. [File test operators](https://tldp.org/LDP/abs/html/fto.html)
5. [Make your scripts portable](https://www.cyberciti.biz/tips/finding-bash-perl-python-portably-using-env.html)
6. [Linux Bash Shell Scripting Tutorial](https://bash.cyberciti.biz/guide/Main_Page)
7. [Shell check](https://github.com/koalaman/shellcheck)

## Summary
**For loop**

Syntax: ```for NAME [in LIST ]; do COMMANDS; done```

If [in LIST] is not present, it is replaced with in $@ and for executes the COMMANDS once for each positional parameter that is set.
NAME can be any variable name, although i is used very often. 
LIST can be any list of words, strings or numbers, which can be literal or generated by any command.
The COMMANDS to execute can also be any operating system commands, script, program or shell statement.
The return status is the exit status of the last command that executes. 
If no commands are executed because LIST does not expand to any items, the return status is zero.

Example:
```
#!/usr/bin/env bash
# specific conversion script for my html files to php

# Assuming beginfile and endfile contain PHP code
beginfile="path/to/beginfile.php"
endfile="path/to/endfile.php"

for file in *.html; do
    new_name=$(echo "$file" | sed 's/html$/php/')
    
    # Copy contents of beginfile to new PHP file
    cat "$beginfile" > "$new_name"
    
    # Append manipulated HTML content to new PHP file
    sed -e '1,25d' "$file" | tac | sed -e '1,21d' | tac >> "$new_name"
    
    # Append contents of endfile to new PHP file
    cat "$endfile" >> "$new_name"
done
```
**Operators**

1. assignment: =
2. arithmetic: +, -, *, /, **, %, +=, -=, *=, /=, %=
3. Bitwise: <<, <<=, >>, >>=, &, &=, |, |=, ^, ^=, ~
4. Logical/boolean: &&, ||, !
5. Comma operator.

**Other comparison operators**

1. Integer comparison: -eq, -ne, -gt, -ge, -lt, <, <=, >, >=

Example: ```if [ "$a" -le "$b" ]``` or ```(("$a" < "$b"))```

2. String comparison: =, ==, <, >, -z, -n

Example: ```if [ "$a" = "$b" ]``` or ```if [[ "$a" < "$b" ]]``` 0r ```if [ "$a" \< "$b" ]```

Example of arithmetic and string comparisons:
```
#!/bin/bash

a=4
b=5

#  Here "a" and "b" can be treated either as integers or strings.
#  Bash permits integer operations and comparisons on variables
#+ whose value consists of all-integer characters.

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# In this particular instance, both "-ne" and "!=" work.

echo

exit 0
```

3. Compound comparison: -a, -o, similar to && and ||

```[ condition1 -a condition2 ]``` or ```[[ condition1 && condition2 ]]```

```[ condition1 -o condition2 ]``` or ```[[ condition1 || condition2 ]]```

**File test operators**

-e/-a, -f, -s, -d, -b, -c, -p, -h, -L, -S, -t, -r, -w, -x, -g, -u, -K, -O, -G, -N, f1 -nt f2, f1 -ot f2, f1 -ef f2, !

**if, if..else..fi, nested ifs, multilevel if-then-else**
Example:
```
#!/bin/bash
# Purpose: Detecting Hardware Errors

# Store path to commands
LOGGER=/usr/bin/logger
FILE=/var/log/mcelog

# Store email settings
AEMAIL="vivek@nixcraft.net.in"
ASUB="H/W Error - $(hostname)"
AMESS="Warning - Hardware errors found on $(hostname) @ $(date). See log file for the details /var/log/mcelog."
OK_MESS="OK: NO Hardware Error Found."
WARN_MESS="ERROR: Hardware Error Found."

# Check if $FILE exists or not
if test ! -f "$FILE" 
then   
	echo "Error - $FILE not found or mcelog is not configured for 64 bit Linux systems."
	exit 1
fi

# okay search for errors in file
error_log=$(grep -c -i "hardware error" $FILE)

# error found or not?
if [ $error_log -gt 0 ]
then    # yes error(s) found, let send an email
	echo "$AMESS" | email -s "$ASUB" $AEMAIL
else    # naa, everything looks okay
	echo "$OK_MESS"
fi
```
**while, for, until loops**

**While Syntax:**
```
while [ condition ]
    do
        command1
        command2
        ..
        ....
        commandN
    done
```
To read a text file line-by-line, use the following syntax:
```
while IFS= read -r line        #Treats each line as a whole, assigning it to the variable line.
    do
        command1 on $line
        command2 on $line
        ..
        ....
        commandN
        done < "/path/to/filename"
```
OR
```
# reads lines from a file but parses each line into multiple fields based on the separator defined by IFS.
# Each field (e.g., field1, field2, ...) in a line is assigned to a corresponding variable.
while IFS= read -r field1 filed2 field3 ... fieldN
    do
        command1 on $field1
        command2 on $field1 and $field3
        ..
        ....
        commandN on $field1 ... $fieldN
    done < "/path/to dir/file name with space"
```
IFS is used to set field separator (default is white space). 
The -r option to read command disables backslash escaping (e.g., \n, \t). 
This is failsafe while read loop for reading text files.

**For Syntax:**
```
for var in item1 item2 ... itemN
    do
        command1
        command2
        ....
        ...
        commandN
    done
```
The for loop numerical explicit list syntax:
```
for var in list-of-values
    do
        command1
        command2
        ....
        ...
        commandN
    done
```
The for loop explicit file list syntax:
```
for var in file1 file2 file3 fileN
    do
        command1
        command2
        ....
        ...
        commandN
    done
```
The for loop variable's contents syntax:
```
for var in $fileNames
    do
        command1
        command2
        ....
        ...
        commandN
    done
```
The for loop command substitution syntax:
```
for var in $(Linux-command-name)
    do
        command1
        command2
        ....
        ...
        commandN
    done
```
The for loop explicit file list using bash array syntax:
```
# define an array   
ArrayName=(~/.config/*.conf)
for var in "${ArrayName[@]}" 
    do
        command1
        command2
        ....
        ...
        commandN
    done
```
The for loop three-expression syntax ( this type of for loop share a common heritage with the C programming language ):
```
for (( EXP1; EXP2; EXP3 ))
do
	command1
	command2
	command3
done
```
**Until syntax:**
```
until [ condition ]
do
   command1
   command2
   ...
   ....
   commandN
done
```
## Tasks

**Task 0:** Create a RSA key pair.

Resources:
1. [How do I set up SSH authentication keys?- Linux and Mac OS users](https://askubuntu.com/questions/61557/how-do-i-set-up-ssh-authentication-keys)
2. [Generate RSA keys with SSH by using PuTTYgen- Windows users](https://docs.rackspace.com/docs/generating-rsa-keys-with-ssh-puttygen)
3. [Data centres](https://www.youtube.com/watch?v=iuqXFC_qIvA&feature=youtu.be&t=46)

![1](https://github.com/Muthoni-Maryanne/alx-system_engineering-devops/assets/107298263/01e0304c-18a6-4f88-bce7-2d96d96ac634)
